% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/make_galah_taxonomy.R
\name{make_taxonomy}
\alias{make_taxonomy}
\title{Get taxonomy via \code{galah::taxa_search()}}
\usage{
make_taxonomy(
  df = NULL,
  taxa_col = "original_name",
  taxonomy_file = tempfile(),
  force_new = list(original_name = NULL, timediff = as.difftime(26, units = "weeks")),
  remove_taxa = c("bold:", "unverified", "undetermined", "unidentified", "annual herb",
    "annual grass", "incertae sedis", "\\\\?", "another\\\\s", "not naturalised in sa",
    "annual tussock grass", "*no id", "spec\\\\.", "aquatic grass"),
  remove_strings = c("\\\\s\\\\-\\\\-\\\\s.*", "\\\\ssp\\\\.$", "\\\\sssp\\\\.$",
    "\\\\sspec\\\\.$", "\\\\ssp$", "\\\\sssp$", "\\\\ssp\\\\d$", "dead",
    "sp.\\\\s.*\\\\(NC\\\\)", "\\\\sx\\\\s.*", "\\\\sX\\\\s.*", "unknown",
    "\\\\scultivar$", "\\\\scomplex$", "\\\\(nc\\\\)", "\\\\saff\\\\."),
  not_names = c("sp", "ssp", "var", "subsp", "subspecies", "form", "race", "nov", "aff",
    "cf", "lineage", "group", "et", "al", "and", "pl", "revised", "nov", "sensu", "lato",
    "hybrid"),
  tri_strings = c("\\\\sssp\\\\s", "\\\\sssp\\\\.\\\\s", "\\\\svar\\\\s",
    "\\\\svar\\\\.\\\\s", "\\\\ssubsp\\\\.", "\\\\ssubspecies", "\\\\sform\\\\)",
    "\\\\sform\\\\s", "\\\\sf\\\\.", "\\\\srace\\\\s", "\\\\srace\\\\)",
    "\\\\sp\\\\.v\\\\."),
  bi_strings = c("all\\\\ssubspecies", "\\\\ssp\\\\s", "\\\\ssp\\\\.\\\\s",
    "\\\\sspecies"),
  atlas = c("Australia"),
  tweak_species = TRUE,
  return_taxonomy = TRUE,
  limit = TRUE,
  needed_ranks = c("species"),
  overrides = NULL
)
}
\arguments{
\item{df}{Dataframe with \code{taxa_col}. Can be \code{NULL} only if taxonomy_file
already exists.}

\item{taxa_col}{Character or index. Name or index of column with taxa names.
Each unique taxa in this column will be queried against \code{galah::search_taxa}
and appear in the results list element \code{lutaxa}in a column called
\code{original_name}}

\item{taxonomy_file}{Character. File path to save results to. File type
ignored. .parquet file used.}

\item{force_new}{List with elements \code{difftime} and any column name from
\code{taxonomy_file}. If \code{taxonomy_file} already exists any column matches between
\code{force_new} and \code{taxonomy_file}, matching levels within that column will be
requeried. Likewise any \code{original_name} that has not been searched since
\code{difftime} will be requeried. Set either to \code{NULL} to ignore.}

\item{remove_taxa}{Character. Rows with regular expressions in
\code{tolower(taxa_col)} that match \code{remove_taxa} are removed (rows are removed).}

\item{remove_strings}{Character. Text that matches \code{remove_strings} is
removed from the \code{taxa_col} before searching (text, not row, is removed).}

\item{not_names}{Character. Text that matches \code{non_name_strings} is used to
remove non-names from original_names before a word count to indicate (guess)
if the original_name is trinomial (original_is_tri field in lutaxa).}

\item{tri_strings, bi_strings}{Character. Text that matches these strings is
used to indicate if the original_name is trinomial or binomial. \code{original_is}
(bin)omial or (tri)nomial appear in the resulting \code{lutaxa}.}

\item{atlas}{Character. Name of galah atlas to use.}

\item{return_taxonomy}{Logical. If \code{TRUE}, a list is returned containing the
best match for each original_name in \code{lutaxa} and additional elements named
for their rank (see \code{envClean::lurank}) with unique rows for that rank. One
element per rank provided in \code{needed_ranks}}

\item{limit}{Logical. If \code{TRUE} the returned list will be limited to those
\code{original_name}s in \code{df}}

\item{needed_ranks}{Character vector of ranks required in the returned list.
Can be "all" or any combination of ranks from \code{envClean::lurank} greater than
or equal to \emph{subspecies}.}

\item{overrides}{Used to override results returned by \code{galah::search_taxa()}.
Dataframe with (at least) columns: \code{taxa_col} and \code{taxa_to_search}.
Can also contain any number of \code{use_x} columns where \code{x} is any of
kingdom, phylum, class, order, family, genus, species, subspecies, variety and form. A two step process then attempts
to find better results than if searched on \code{taxa_col}. Step 1 searches for
\code{taxa_to_search} instead of \code{taxa_col}. If any \code{use_x} columns are present,
step 2 then checks that the results from step 1 have a result at \code{x}. If not,
level \code{x} results will be taken from \code{use_x}.}

\item{tweak_species.}{Logical. If \code{TRUE} (default) and the returned \code{species}
column result ends in a full stop, the values returned in the \code{species}
column will be directly taken from the \code{scientific_name} column. See details.}
}
\value{
Null or list (depending on \code{return_taxonomy}). Writes
\code{taxonomy_file}. \code{taxa_col} will be \code{original_name} in any outputs. Note that
\code{taxa_col}, as \code{original_name}, will have any quotes removed.
If list, then elements:
\itemize{
\item raw - the 'raw' results returned from \code{galah::search_taxa()}, tweaked
by: column \code{rank} is an ordered factor as per \code{envClean::lurank};
rank_adj is a new column that will reflect the rank column unless rank is
less than subspecies, in which case it will be subspecies; and
original_is_(bi or tri) are new columns
\item needed_ranks - One element for each rank specified in \code{needed_ranks}.
\itemize{
\item lutaxa - dataframe. For each unique name in \code{taxa_col}, the best
\code{taxa} taxonomic bin to use, for each \code{original_name}, taking into
account each level of \code{needed_ranks}
\itemize{
\item original_name - unique values from \code{taxa_col}
\item match_type - directly from \code{galah::search_taxa()}
\item matched_rank - \code{rank} column from \code{galah::search_taxa()}
\item returned_rank - the rank of the \code{taxa} returned for each
\code{original_name}. This will never be lower than \code{needed_rank} but
may be higher than \code{needed_rank} if no match was available at
\code{needed_rank}. Use this 'rank' to filter bins in a cleaning
workflow
\item taxa - the best taxa available for \code{original_name} at
\code{needed_rank}, perhaps taking into account \code{overrides}
\item override - is the \code{taxa} the result of an override?
\item original_is_tri,original_is_bi - Experimental. Is the
\code{original_name} a trinomial or binomiail? Highlights cases where
the matched rank is > subspecies but the \code{original_name} is
probably a subspecies. Guesses are based on a word count after
removal of: \code{not_names}; numbers; punctuation; capitalised words
that are not the first word; and single letter 'words'.
\code{bi_strings} or \code{tri_strings} override the guess - flagging TRUE.
Note, clearly, this is only an (informed) guess at whether the
\code{original_name} is binomial or trinomial.
}
\item taxonomy - dataframe. For each \code{taxa} in \code{lutaxa} a row of
taxonomic hierarchy
}
}
}
\description{
Only queries galah for taxa not already in \code{taxonomy_file}. Can return a list,
for several levels of taxonomic hierarchy, with the 'best' match at that
level. For example, if 'genus' is provided in \code{needed_ranks}, the returned
list will have an element 'genus' that contains, in a column named \code{taxa},
and for each of the original names provided, the best result at genus level
\emph{or higher} (in cases where no genus level match was available).
}
\details{
The argument \code{tweak_species} replaces the \code{galah::search_taxa()} result in
the \code{species} column with the result in the \code{scientific_name} column. This
attempt to deal with instances where \code{galah::search_taxa()} returns odd
results in \code{species} but good results in \code{scientific_name}. e.g.
galah::search_taxa("Acacia sp. Small Red-leaved Wattle (J.B.Williams 95033)")
returns \code{spec.} in the species column but
\verb{Acacia sp. Small Red-leaved Wattle (J.B.Williams 95033)} in the
\code{scientific_name} column

Previous \code{envClean::make_taxonomy()} function is still available via
\code{envClean::make_gbif_taxonomy()}
}
\examples{

  # setup
  # library("envClean")

  temp_file <- tempfile()

  taxa_df <- tibble::tibble(taxa = c("Charadrius rubricollis"
                                     , "Thinornis cucullatus"
                                     , "Melithreptus gularis laetior"
                                     , "Melithreptus gularis gularis"
                                     , "Eucalyptus viminalis"
                                     , "Eucalyptus viminalis cygnetensis"
                                     , "Eucalyptus"
                                     , "Charadrius mongolus all subspecies"
                                     , "Bettongia lesueur Barrow and Boodie Islands subspecies"
                                     , "Lagorchestes hirsutus Central Australian subspecies"
                                     , "Perameles gunnii Victorian subspecies"
                                     , "Pterostylis sp. Rock ledges (pl. 185, Bates & Weber 1990)"
                                     , "Spyridium glabrisepalum"
                                     , "Spyridium eriocephalum var. glabrisepalum"
                                     , "Petrogale lateralis (MacDonnell Ranges race)"
                                     , "Gehyra montium (revised)"
                                     , "Korthalsella japonica f. japonica"
                                     , "Galaxias sp. nov. 'Hunter'"
                                     , "Some rubbish"
                                     , "Senna artemisioides subsp x artemisioides"
                                     , "Halosarcia sp.  (NC)"
                                     , "TERMITOIDAE sp." # 'epifamily'
                                     )
                            )

  # make taxonomy (returns list and writes taxonomy_file)
  taxonomy <- make_taxonomy(df = taxa_df
                            , taxa_col = "taxa"
                            , taxonomy_file = temp_file
                            , needed_ranks = c("kingdom", "genus", "species", "subspecies")
                            )
  taxonomy$raw
  taxonomy$kingdom
  taxonomy$genus
  taxonomy$species
  taxonomy$subspecies

  # query more taxa (results are added to taxonomy_file but only the new taxa are returned (default `limit = TRUE`)
  more_taxa <- tibble::tibble(original_name = c("Amytornis whitei"
                                                , "Amytornis striatus"
                                                , "Amytornis modestus (North, 1902)"
                                                , "Amytornis modestus modestus"
                                                , "Amytornis modestus cowarie"
                                                )
                              )

  make_taxonomy(df = more_taxa
                , taxonomy_file = temp_file
                , needed_ranks = c("species")
                )

  # no dataframe supplied - all results in taxonomy_file returned
  make_taxonomy(taxonomy_file = temp_file
                , needed_ranks = c("subspecies")
                )

  # Try automatic overrides
  auto_overrides <- make_unmatched_overrides(df = taxa_df
                                             , taxa_col = "taxa"
                                             , taxonomy = taxonomy
                                             , target_rank = "species"
                                             )

  # overrrides
  overrides <- envClean::taxonomy_overrides

  # C. rubricollis binned to Phalarope lobatus at species level!
  taxonomy <- make_taxonomy(df = overrides
                            , taxonomy_file = temp_file
                            , needed_ranks = c("species", "subspecies")
                            )

  taxonomy$species$lutaxa \%>\%
    dplyr::filter(grepl("rubricollis", original_name))

  # add in override - C. rubricollis is binned to T. cucullatus at species level
  taxonomy <- make_taxonomy(df = overrides
                            , taxonomy_file = temp_file
                            , needed_ranks = c("species", "subspecies")
                            , overrides = overrides
                            )

  taxonomy$species$lutaxa \%>\%
    dplyr::filter(grepl("rubricollis", original_name))


  # tweak_species example
  make_taxonomy(df = tibble::tibble(original_name = "Acacia sp. Small Red-leaved Wattle (J.B.Williams 95033)")
                , tweak_species = FALSE
                )$raw \%>\%
    dplyr::select(original_name, scientific_name, species)

  make_taxonomy(df = tibble::tibble(original_name = "Acacia sp. Small Red-leaved Wattle (J.B.Williams 95033)")
                , tweak_species = TRUE
                )$raw \%>\%
    dplyr::select(original_name, scientific_name, species)

  # clean up
  rm(taxonomy)
  unlist(paste0(temp_file, ".parquet"))
}
